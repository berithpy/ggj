import generate from 'generate-maze'
import { doorFactory, DOOR_ORIENTATION } from './actors/door'
import config from './config'
import Item from './actors/item'

var TILE_TYPE = {
  CLEAR: 0,
  WALL: 1,
  GOAL: 2,
  PLAYER_WALL: 3,
};

/**
 * Generates a maze and populates it doors and objects.
 * @param {Number} width Width of the maze. MUST be odd.
 * @param {Number} height Height of the maze. MUST be odd.
 * @param {Player} player Player instance to locate inside the maze. The player
 * will be placed in the starting position of the maze.
 * @returns {Array[Array]} Matrix of the specified width and height containing 
 * TILE_TYPE entries.
 */
function generateMaze(width, height, player) {
  if (width % 2 === 0 || height % 2 === 0)
    throw 'Cannot generate maze with even dimensions. Dimensions MUST be odd!';
  
  // This generator outputs a matrix of objects with the walls for each 
  // coordinate, generated by the Eller algorithm. 
  // We will transform the Eller matrix to a matrix of TILE_TYPE entries. 
  // Eller matrixes require less elements to represent a maze, so we need 
  // to lower the number of coordinates required from the generator.
  let gen = generate((width + 1) / 2, (height + 1) / 2);

  // Convert the Eller matrix to a TILE_TYPE matrix.
  // No borders are included in the generated TILE_TYPE matrix, they are 
  // expected to be guaranteed by the game
  let tilemapData = [];
  for (let x=0; x < height; x += 2) {
    tilemapData.push([]);
    if (x < height - 1)
      tilemapData.push([]); 
    for (let y=0; y < width; y += 2) {
      let piece = gen[x/2][y/2];
      // Set the current position to CLEAR
      tilemapData[x][y] = TILE_TYPE.CLEAR;
      // Set the corner down right to wall
      if (x < height - 1 && y < width - 1)
        tilemapData[x+1][y+1] = TILE_TYPE.WALL;
      // Set the right and bottom walls
      if (x < height - 1)
        tilemapData[x+1][y] = piece.bottom ? TILE_TYPE.WALL : TILE_TYPE.CLEAR;
      if (y < width - 1)
        tilemapData[x][y+1] = piece.right ? TILE_TYPE.WALL : TILE_TYPE.CLEAR;
    }
  }

  // Set goal
  // HACK This is out of the established bounds
  let candidates = [];
  for (let x=0; x < height; x += 1) {
    // Check if there's a clear path to be able to get to the end
    if (tilemapData[x][width-1] === TILE_TYPE.CLEAR)
      candidates.push(x);
    // Create a wall in the next column to set the end
    tilemapData[x][width] = TILE_TYPE.WALL;
  }
  let x = candidates[Math.floor(Math.random() * candidates.length)];
  tilemapData[x][width] = TILE_TYPE.GOAL;
  
  // Set player start position
  candidates = [];
  for (let x=0; x < height; x += 1) {
    // Check if there's a clear path to be able to get to the end
    if (tilemapData[x][0] === TILE_TYPE.CLEAR)
      candidates.push(x);
  }
  x = candidates[Math.floor(Math.random() * candidates.length)];
  // Set player to the selected position
  player.position.x = 0;
  player.position.y = x * config.tileWidth;

  return tilemapData;
};

/**
 * Generate a group of doors in the specified maze area.
 * @param {Array[Array]} maze Array containing the maze.
 * @param {Number} horizontalOffset Horizontal offset in tiles from the origin
 * where the maze starts.
 * @param {Number} verticalOffset Vertical offset in tiles from the origin
 * where the maze starts.
 * @param {Phaser.Group} actorGroup Group that will hold the players and 
 * generated doors and items.
 * @param {Phaser.Group} morseGroup Group that will hold the morse signals.
 * @param {Number} [doorChance=0.5] Number between 0 and 1 with the chance to 
 * create a door. A higher number represents a higher chance to have a door.
 */
function generateDoors(maze, horizontalOffset, verticalOffset, player, 
                       actorGroup, morseGroup, doorChance=0.5)
{
  // Being lazy and copying the whole structure to be able to place doors
  let ref = maze.map(function(arr) { return arr.slice(); });
  // Mark where the player is so a door does not spawn in the same spot
  ref[player.x / config.tileWidth][0] = 'X';

  let width = maze[0].length;
  let height = maze.length;

  // Set maze doors:
  // * Doors must be place on coordinates that have either both left and right 
  //   or up and down walled.
  // * Doors cannot be next to other doors.
  if (!doorChance && doorChance !== 0)
    doorChance = 0.5;
  for (let x=0; x < height; x += 1) {
    for (let y=0; y < width; y += 1) {
      // If placement roll does not succeed skip placement
      if (Math.random() > doorChance || ref[x][y] !== TILE_TYPE.CLEAR) 
        continue

      // Wall coordinate flags
      let wall_up = x > 0 ? ref[x-1][y] === TILE_TYPE.WALL : true;
      let wall_down = x < height-1 ? ref[x+1][y] === TILE_TYPE.WALL : true;
      let wall_left = y > 0 ? ref[x][y-1] === TILE_TYPE.WALL : true;
      let wall_right = y < width ? ref[x][y+1] === TILE_TYPE.WALL : true;
      // Clear coordinate flags
      let clear_up = x > 0 ? ref[x-1][y] === TILE_TYPE.CLEAR : false;
      let clear_down = x < height-1 ? ref[x+1][y] === TILE_TYPE.CLEAR : false;
      let clear_left = y > 0 ? ref[x][y-1] === TILE_TYPE.CLEAR : false;
      let clear_right = y < width ? ref[x][y+1] === TILE_TYPE.CLEAR : false;

      // Place door
      if (wall_up && wall_down && clear_left && clear_right) 
        ref[x][y] = doorFactory(
          actorGroup, 
          y + horizontalOffset, 
          x + verticalOffset, 
          DOOR_ORIENTATION.UD,
          undefined, 
          morseGroup
        );
      if (wall_left && wall_right && clear_up && clear_down) 
        ref[x][y] = doorFactory(
          actorGroup, 
          y + horizontalOffset, 
          x + verticalOffset, 
          DOOR_ORIENTATION.LR,
          undefined, 
          morseGroup
        );
    }
  }
}

/**
 * Generate a group of doors in the specified maze area.
 * @param {Array[Array]} maze Array containing the maze.
 * @param {Number} horizontalOffset Horizontal offset in tiles from the origin
 * where the maze starts.
 * @param {Number} verticalOffset Vertical offset in tiles from the origin
 * where the maze starts.
 * @param {Phaser.Group} actorGroup Group that will hold the players and 
 * generated doors and items.
 * @param {Number} [itemChance=0.5] Number between 0 and 1 with the chance to 
 * create an item. A higher number represents a higher chance to have a item.
 */
function generateItems(maze, horizontalOffset, verticalOffset, actorGroup,
  doorChance=0.5)
{
  // Being lazy and copying the whole structure to be able to place items
  let ref = maze.map(function(arr) { return arr.slice(); });
  // Mark where the player is so a door does not spawn in the same spot
  ref[player.x / config.tileWidth][0] = 'X';

  // Set maze items.
  // if (!itemChance && itemChance !== 0)
  //   itemChance = 0.2;
  // for (let x=0; x < height; x += 1) {
  //   for (let y=0; y < width; y += 1) {
  //     // If placement roll does not succeed skip placement
  //     if (Math.random() > itemChance || ref[x][y] !== TILE_TYPE.CLEAR) 
  //       continue

  //     ref[x][y] = generateItem();
  //   }
  // }
}

module.exports = {
  TILE_TYPE,
  generateMaze,
  generateDoors,
  generateItems,
}
