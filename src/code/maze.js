import generate from 'generate-maze'
import { doorFactory, DOOR_ORIENTATION } from './actors/door'
import config from './config'
import Item from './actors/item'

var TILE_TYPE = {
  CLEAR: 0,
  WALL: 1,
  GOAL: 2,
  PLAYER_WALL: 3,
};

/**
 * Generates a maze and populates it doors and objects.
 * @param {Array[Array]} tilemapData Tilemap data. This group will hold the 
 * generated maze tiles.
 * @param {Number} horizontalOffset Tilemap horizontal offset from origin in 
 * which to place the generated maze.
 * @param {Number} verticalOffset Tilemap vertical offset from origin in which 
 * to place the generated maze.
 * @param {Number} width Width of the maze. MUST be odd.
 * @param {Number} height Height of the maze. MUST be odd.
 * @param {Player} player Player instance to locate inside the maze. The player
 * will be placed in the starting position of the maze.
 * @param {Phaser.Group} actorGroup Group that will hold the players and 
 * generated doors and items.
 * @param {Number} doorChance Number between 0 and 1 with the chance to create 
 * a door. A higher number represents a higher chance to have a door.
 * @param {Number} itemChance Number between 0 and 1 with the chance to create 
 * an item. A higher number represents a higher chance to create an item. Items 
 * are created after doors, so a higher door chance will reduce the number of 
 * generated items.
 * @returns {Array[Array]} Matrix of the specified width and height containing 
 * TILE_TYPE entries.
 */
function generateMaze(tilemapData,
                      horizontalOffset, verticalOffset,
                      width, height,
                      player, actorGroup,
                      doorChance, itemChance) {
  if (width % 2 === 0 || height % 2 === 0)
    throw 'Cannot generate maze with even dimensions. Dimensions MUST be odd!';

  // This generator outputs a matrix of objects with the walls for each 
  // coordinate, generated by the Eller algorithm. 
  // We will transform the Eller matrix to a matrix of TILE_TYPE entries. 
  // Eller matrixes require less elements to represent a maze, so we need 
  // to lower the number of coordinates required from the generator.
  let gen = generate((width + 1) / 2, (height + 1) / 2);

  // Update width and height to account for offsets
  height = height + verticalOffset;
  width = width + horizontalOffset;

  // Convert the Eller matrix to a TILE_TYPE matrix.
  // No borders are included in the generated TILE_TYPE matrix, they are 
  // expected to be guaranteed by the game
  for (let x=verticalOffset; x < height; x += 2) {
    for (let y=horizontalOffset; y < width; y += 2) {
      let piece = gen[(x-verticalOffset)/2][(y-horizontalOffset)/2];
      // Set the current position to CLEAR
      tilemapData[x][y] = TILE_TYPE.CLEAR;
      // Set the corner down right to wall
      if (x < height - 1 && y < width - 1)
        tilemapData[x+1][y+1] = TILE_TYPE.WALL;
      // Set the right and bottom walls
      if (x < height - 1)
        tilemapData[x+1][y] = piece.bottom ? TILE_TYPE.WALL : TILE_TYPE.CLEAR;
      if (y < width - 1)
        tilemapData[x][y+1] = piece.right ? TILE_TYPE.WALL : TILE_TYPE.CLEAR;
    }
  }

  // Set goal
  // HACK this is out of the established bounds
  let candidates = [];
  for (let x=verticalOffset; x < height; x += 1) {
    // Check if there's a clear path to be able to get to the end
    if (tilemapData[x][width-1] === TILE_TYPE.CLEAR)
      candidates.push(x);
    // Create a wall in the next column to set the end
    tilemapData[x][width] = TILE_TYPE.WALL;
  }
  let x = candidates[Math.floor(Math.random() * candidates.length)];
  tilemapData[x][width] = TILE_TYPE.GOAL;

  // Being lazy and copying the whole structure to be able to place 
  let ref = tilemapData.map(function(arr) { return arr.slice(); });
  
  // Set player start position
  candidates = [];
  for (let x=verticalOffset; x < height; x += 1) {
    // Check if there's a clear path to be able to get to the end
    if (tilemapData[x][0] === TILE_TYPE.CLEAR)
      candidates.push(x);
  }
  x = candidates[Math.floor(Math.random() * candidates.length)];
  // Mark the tile so that doors and items don't consider this position
  ref[x][0] = 'X';
  // Set player to the selected position
  player.x = x * config.tileWidth;
  player.y = 0;

  // Set maze doors:
  // * Doors must be place on coordinates that have either both left and right 
  //   or up and down walled.
  // * Doors cannot be next to other doors.
  if (!doorChance && doorChance !== 0)
    doorChance = 0.5;
  for (let x=verticalOffset; x < height; x += 1) {
    for (let y=horizontalOffset; y < width; y += 1) {
      // If placement roll does not succeed skip placement
      if (Math.random() > doorChance || ref[x][y] !== TILE_TYPE.CLEAR) 
        continue

      // Wall coordinate flags
      let wall_up = x > 0 ? ref[x-1][y] === TILE_TYPE.WALL : true;
      let wall_down = x < height-1 ? ref[x+1][y] === TILE_TYPE.WALL : true;
      let wall_left = y > 0 ? ref[x][y-1] === TILE_TYPE.WALL : true;
      let wall_right = y < width ? ref[x][y+1] === TILE_TYPE.WALL : true;
      // Clear coordinate flags
      let clear_up = x > 0 ? ref[x-1][y] === TILE_TYPE.CLEAR : false;
      let clear_down = x < height-1 ? ref[x+1][y] === TILE_TYPE.CLEAR : false;
      let clear_left = y > 0 ? ref[x][y-1] === TILE_TYPE.CLEAR : false;
      let clear_right = y < width ? ref[x][y+1] === TILE_TYPE.CLEAR : false;

      // Place door
      if (wall_up && wall_down && clear_left && clear_right) 
        ref[x][y] = doorFactory(actorGroup, y, x, DOOR_ORIENTATION.UD);
      if (wall_left && wall_right && clear_up && clear_down)
        ref[x][y] = doorFactory(actorGroup, y, x, DOOR_ORIENTATION.LR);
    }
  }

  // Set maze items.
  // if (!itemChance && itemChance !== 0)
  //   itemChance = 0.2;
  // for (let x=verticalOffset; x < height; x += 1) {
  //   for (let y=horizontalOffset; y < width; y += 1) {
  //     // If placement roll does not succeed skip placement
  //     if (Math.random() > itemChance || ref[x][y] !== TILE_TYPE.CLEAR) 
  //       continue

  //     ref[x][y] = generateItem();
  //   }
  // }

  return tilemapData;
};

module.exports = {
  TILE_TYPE,
  generateMaze,
}
